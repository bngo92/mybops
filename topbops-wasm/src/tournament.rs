#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Node<T> {
    pub item: T,
    pub disabled: bool,
}

fn interleave(src: &mut Vec<i32>, dst: &mut Vec<i32>) {
    *dst = Interleave::new(src.drain(..).map(|i| -i), std::mem::take(dst).into_iter()).collect();
}

struct Interleave<I: Iterator, J: Iterator<Item = I::Item>> {
    iter1: I,
    iter2: J,
    flag: bool,
}

impl<I: Iterator, J: Iterator<Item = I::Item>> Interleave<I, J> {
    fn new(iter1: I, iter2: J) -> Interleave<I, J> {
        Interleave {
            iter1,
            iter2,
            flag: false,
        }
    }
}

impl<I: Iterator, J: Iterator<Item = I::Item>> Iterator for Interleave<I, J> {
    type Item = I::Item;
    fn next(&mut self) -> Option<I::Item> {
        self.flag = !self.flag;
        match self.flag {
            true => self.iter1.next(),
            false => self.iter2.next(),
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        let h1 = self.iter1.size_hint();
        let h2 = self.iter2.size_hint();
        (h1.0 + h2.0, h1.1.zip(h1.1).map(|(h1, h2)| h1 + h2))
    }
}

/// Generate a balanced binary tree with enough leaves for all items.
///
/// Items are ordered such that high seeds are matched with low seeds or have bye rounds.
/// The tree is generated by splitting leaf nodes:
///
///      *
///     / \
///    1   2
///
///      *
///     / \
///   *     *
///  / \   / \
/// 1   4 3   2
///
/// The tree is actually generated by precalculating indexes instead of iteratively splitting leaf nodes.
/// The tree is also represented as a flat vec.
/// Spaces between nodes represent results between children nodes.
///
/// Start:
/// 1
/// *
/// 4
/// *
/// 3
/// *
/// 2
///
/// End:
/// 1
/// 1
/// 4
/// 1
/// 3
/// 2
/// 2
pub fn generate_tournament<T: Clone>(v: Vec<T>, default: T) -> Vec<Option<Node<T>>> {
    let depth = (v.len() as f64).log2().ceil() as u32;

    // Build arrays of steps between items with ascending seeds
    // Steps for the next level can be calculated from the previous level
    let mut top = Vec::new();
    let mut next_top = Vec::new();
    let mut bottom = Vec::new();
    let mut next_bottom = Vec::new();
    for d in 0..depth + 1 {
        let len = (2 << d) - 2;
        let mut current = 0;
        interleave(&mut next_top, &mut top);
        for next_i in &top {
            let i = len - 2 * current;
            next_top.push(i);
            current += i + next_i;
        }
        let i = len - 2 * current;
        next_top.push(i);
        current += i - 2;
        interleave(&mut next_bottom, &mut bottom);
        for next_i in &bottom {
            let i = len - 2 * current;
            next_bottom.push(i);
            current += i + next_i;
        }
        let i = len - 2 * current;
        next_bottom.push(i);
    }

    let len = (1 << depth) - v.len();
    let iter = std::iter::once(0)
        .chain(Interleave::new(next_top.into_iter(), top.into_iter()))
        .chain(std::iter::once(-2))
        .chain(Interleave::new(next_bottom.into_iter(), bottom.into_iter()));
    let mut next: Vec<_> = [
        None,
        Some(Node {
            item: default,
            disabled: true,
        }),
    ]
    .into_iter()
    .cycle()
    .take((2 << depth) - 1)
    .collect();
    let mut current = 0;
    for (i, (item, step)) in v.into_iter().zip(iter).enumerate() {
        current += step;
        let index = if len > i {
            if current % 4 == 0 {
                current + 1
            } else {
                current - 1
            }
        } else {
            current
        };
        next[index as usize] = Some(Node {
            item,
            disabled: false,
        });
    }
    next
}
